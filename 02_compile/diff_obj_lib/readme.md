# オブジェクトファイルとライブラリファイルの違い

C言語のソースファイルをコンパイルするとオブジェクトファイルが出来る。
また、コンパイルオプションでライブラリを作成することも出来る。

オブジェクトファイルもライブラリファイルもどちらも機械語を含んだバイナリファイルである。

ライブラリファイルはオブジェクトファイルをまとめたものだが、単純に並べて一つにした
だけのものなのか、なにか追加・修正されているのか？確かめてみる。

## キーワード：
 - オブジェクトファイルフォーマット：ELF, Mach-O, PE
 - セクション、セグメント、リンカ、ローダ、
 - シンボルテーブル、シンボルテーブルの索引（インデックス）

# オブジェクトファイルの生成
サンプルとして用意したC言語のソースコードはこれ。

```C:foo_bar.c
int foo(int x){
	int a = 2;
	return a+x;
}

int bar(int y){
	const int b=3;
	return b*3;
}

```
gcc でコンパイルしてオブジェクトファイルを生成する。
```
$ gcc -c foo_bar.c
```
foo_bar.o が生成される。

# ライブラリファイルの生成
オブジェクトファイル foo_bar.o から静的ライブラリ foo_bar.a を作成する。
```
$ ar rv foo_bar.a foo_bar.o
ar: creating archive foo_bar.a
a - foo_bar.o
```

# オブジェクトファイルとライブラリファイルの比較
まずはファイルサイズを比較してみる。
```
$ ls -l foo_bar.o foo_bar.a
total 32
-rw-r--r--  1 kzono  staff   960  9 29 11:24 foo_bar.a
-rw-r--r--  1 kzono  staff   748  9 29 10:45 foo_bar.o
```
この 960 - 748 = 212 byte がなんなのかをこれから明らかにしていく。

## シンボルテーブル

オブジェクトファイルにはシンボルテーブルが含まれている。
nm コマンドを使うと、シンボルテーブルを表示できる。

```
$ nm foo_bar.o
0000000000000020 T _bar
0000000000000000 T _foo
```
```
foo_bar.a(foo_bar.o):
0000000000000020 T _bar
0000000000000000 T _foo
```

オブジェクトファイルもライブラリファイルも、含まれているシンボルテーブルは
同じであることがわかる。

## シンボルテーブルの索引
nm コマンドには、--print-armap というオプションがあり、シンボルテーブルの索引を
表示することが出来る。

```
$ nm --print-armap foo_bar.o
0000000000000020 T _bar
0000000000000000 T _foo
```
foo_bar.o ｎ含まれているシンボルテーブルだけが表示された。

```
$ nm --print-armap foo_bar.a
Archive map
_bar in foo_bar.o
_foo in foo_bar.o


foo_bar.a(foo_bar.o):
0000000000000020 T _bar
0000000000000000 T _foo
```
最初の３行がシンボルテーブルの索引らしい。

[ar - コマンド (プログラム) の説明 - Linux コマンド集 一覧表](http://kazmax.zpp.jp/cmd/a/ar.1.html)

> ar は、書庫に入っているリロケータブルなオブジェクトモジュールに含まれる
> シ ンボルの索引 (index) を作成することができる。これは修正子 (modifier)
>  `s ' が指定されたときの動作である。一度作成されると、この索引は ar によって
> 書庫の内容が変更されるたびに更新される (ただし `q ' によっ て書庫が更新された場合を除く)。
> このような索引を持った書庫では、ライブ ラリとしてリンクされる場合の速度が向上する。
> またライブラリの内部に含まれる ルーチンが、書庫内部での位置によらずお互いを
> 呼び出すことができるように なる。 
> `nm -s ' または `nm --print-armap ' とすればこの索引をリ ストすることができる。
> 書庫に索引がない場合は、 ar の別名である ranlib を用いて索引を追加することもできる。


# バイナリファイルのダンプ
シンボルテーブルの索引の存在の有無がオブジェクトファイルとライブラリファイルの違いだった。
これをバイナリレベルで確認する。

バイナリダンプ出来るコマンド
 - od
 - hexdump
 - xxd


# バイナリダンプの比較
```
$ xxd foo_bar.o > foo_bar_o.xxd
$ xxd foo_bar.a > foo_bar_a.xxd
```


# 結論

# 宿題
シンボルテーブルの索引はハッシュテーブルらしいのだが、
関数名からそのアドレスを検索できるようになっているはず。
関数名 foo とそのアドレスが、索引のどこにあるのか、バイナリレベルで
確認したい。

ハッシュ関数自体は調べる気はないが、関数名やおそらく変数名も
管理されているはず。変数を追加して、索引部分がどう変わるのか、
バイナリダンプして調べれば、対応関係がわかるはず。
関数や変数のアドレスは、objdump や nm でわかるはずなので。


